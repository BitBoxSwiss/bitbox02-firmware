// Copyright 2024 Shift Crypto AG
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![no_std]

#[repr(Rust, packed)]
struct P {
    // Null-terminated strings, saving a few bytes of binary space per token stored versus using
    // `&str`, which also stores the size of the string. We could further optimize for space by
    // grouping tokens by unit of len 1, 2, 3, ..., removing the need for a null terminator byte, as
    // most of them are length 3.
    pub unit: *const u8,
    pub contract_address: [u8; 20],
}

pub struct Params {
    pub unit: &'static str,
    pub contract_address: [u8; 20],
    pub decimals: u8,
}

impl Params {
    fn from_p(p: &P, decimals: u8, unit_len: u8) -> Self {
        Params {
            unit: unsafe {
                core::str::from_utf8_unchecked(core::slice::from_raw_parts(
                    p.unit,
                    unit_len as usize,
                ))
            },
            contract_address: p.contract_address,
            decimals,
        }
    }
}

// Includes `const PARAMS_18: &[P] = ...` for each existing decimals.
// And `const ALL: &[(u8, &[P])] = ...` listing all params by decimals so we can iterate them.
// This way we don't repeat the decimal in every token, saving ~1 byte of binary space per token.
// Generated by build.rs.
include!(concat!(env!("OUT_DIR"), "/tokens.rs"));

pub fn get(chain_id: u64, contract_address: [u8; 20]) -> Option<Params> {
    if chain_id != 1 {
        return None;
    }
    for &(decimals, unit_len, params) in ALL.iter() {
        let result = params
            .binary_search_by_key(&contract_address, |p| p.contract_address)
            .ok()
            .map(|idx| Params::from_p(&params[idx], decimals, unit_len));
        if result.is_some() {
            return result;
        }
    }
    None
}

#[cfg(test)]
mod tests {
    use super::*;

    extern crate std;
    use std::fs::File;
    use std::io::{self, BufRead};
    use std::vec::Vec;

    #[test]
    fn test_get() {
        // Not found for chainID 0.
        assert!(get(
            0,
            *b"\x0f\x72\x71\x4b\x35\xa3\x66\x28\x5d\xf8\x58\x86\xa2\xee\x17\x46\x01\x29\x2a\x17"
        )
        .is_none());

        // Contract address doesn't exist on chainID 1.
        assert!(get(
            1,
            *b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x17"
        )
        .is_none());

        let params = get(
            1,
            *b"\x00\x00\x00\x00\x00\x08\x5d\x47\x80\xb7\x31\x19\xb6\x44\xae\x5e\xcd\x22\xb3\x76",
        )
        .unwrap();
        assert_eq!(params.unit, "TUSD");
        assert_eq!(
            params.contract_address,
            *b"\x00\x00\x00\x00\x00\x08\x5d\x47\x80\xb7\x31\x19\xb6\x44\xae\x5e\xcd\x22\xb3\x76"
        );
        assert_eq!(params.decimals, 18);

        let params = get(
            1,
            *b"\xbf\x05\x57\x19\x88\xda\xab\x22\xd3\x3c\x28\xbb\xb1\x35\x66\xea\xe9\xde\xe6\x26",
        )
        .unwrap();
        assert_eq!(params.unit, "999");
        assert_eq!(params.decimals, 3);
    }

    #[test]
    fn test_get_all() {
        let file = File::open("src/tokens.txt").unwrap();
        let reader = io::BufReader::new(file);

        for line in reader.lines() {
            let line = line.unwrap();
            if line.starts_with('#') {
                continue;
            }
            let parts: Vec<&str> = line.split(';').collect();
            let expected_unit = parts[0];
            let contract_address: [u8; 20] = hex::decode(parts[1].strip_prefix("0x").unwrap())
                .unwrap()
                .try_into()
                .unwrap();
            let expected_decimals: u8 = parts[2].parse().unwrap();

            let params = get(1, contract_address).unwrap();
            assert_eq!(params.contract_address, contract_address,);
            assert_eq!(params.unit, expected_unit);
            assert_eq!(params.decimals, expected_decimals);
        }
    }
}
